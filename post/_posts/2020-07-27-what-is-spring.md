---
layout: post
title: Spring이란 무엇인가?
noindex: true
comments: true
---
Spring의 장점은 무엇인가?라는 질문에 보통 다들 IoC/DI, 경량 프레임워크, 컨테이너 등등
잘 이야기 할 것이다. 그럼 Spring란 무엇인가? 라는 질문에 대해서는 뭐라고 대답해야할까?
막상 저 질문에 대한 답을 하려고하면 잘 생각이 나지 않는다.
그래서 오늘은 도대체 Spring란 무엇인지 정리해보려고 한다.
---

### Spring의 정의
---
사실 Spring은 정확히 이거다. 라는 정의는 어려운 것 같다. 한마디로 정의하기엔 너무나도 많은 철학과 기능들이 들어가 있으니 말이다.
그래도 어떤 것에 대한 정의는 본질을 담고 있기 때문에 정의를 알아야 그 것에 대한 이해도 깊어 질 것이다.
그래서 잘 알려진 Spring의 대한 정의는 아래와 같다.

> 자바 엔터프라이즈 개발을 편하게 해주는 오픈소스 경량급 애플리케이션 프레임워크

위의 정의를 보면, 정확히 이거다 라는 감이 오지 않는다. 
하지만, 위의 정의는 Spring의 중요한 특징을 잘 담고 있는 정의이다.

#### Application Framework(애플리케이션 프레임워크)

[저번 글](https://cargun3.github.io/post/2020-06-08-framework-library/)에서 정리한 Library와 Framework는 결국 `어떤 문제를 해결하기 위한 방법`이라고 이야기하였다. 이 것을 다시 말하면 `어떤 문제를 해결하기 위해 특정 부분이나 한 가지 기술에 특화`되었다고도 할 수 있다.
포맷과 출력장치를 유연하게 변경할 수 있는 애플리케이션 로그 기능을 제공한다거나, 간단한 설정만으로 관계형 DB와 자바오브젝트를 매핑해주는 ORM 기술을 제공하는 것들을 예로 들 수 있다. 
그래서 결국 Library와 Framework는 `애플리케이션의 특정 계층에서 주로 동작하는 한가지 기술 분야에 집중`된다.

하지만 **애플리케이션 프레임워크는 특정 계층이나, 기술, 업무 분야에 국한되지 않고 애츨리케이션의 전 영역을 포괄하는 범용적인 프레임워크**를 말한다.
애플리케이션 프레임워크는 **애플리케이션 개발의 전 과정을 빠르고 편리하며 효율적으로 진행하는데 일차적인 목표를 두는 프레임워크**이다.

사실 스프링이 자바 엔터프라이즈 개발의 전 영역을 포괄하는 애플리케이션 프레임워크가 된 데는 스프링의 탄생배경과 밀접한 관련이 있다.
스프링은 처음부터 독자적으로 개발된 프레임워크는 아니였다. 스프링의 기원은 J2EE 기술서적에 딸린 예제 코드이다. 로드 존슨이라는 사람이 2003년에 [Expert One-on-One J2EE Design and Development]라는 책을 출간했는데 책의 주된 전략은 `항상 프레임워크로 접근하라`라는 것 이었다.
그것과 함께 당연히 예제로 사용하게 될 프레임워크를 제공하였는데 **이러한 전략이 개발자들의 관심을 끌기 시작해 책에 나온 프레임워크를 로드 존슨이라는 사람과 함께 오픈소스 프로젝트로 발전하기에 이르러 결국 오늘날의 스프링이 되었다.**

> 애플리케이션의 전 영역을 관통하는 일관된 프로그래밍 모델과 핵심 기술을 바탕으로 해서 각 분야의 특성에 맞는 필요를 채워주고 있기 때문에, 애플리케이션을 빠르고 효과적으로 개발할 수가 있다. 
바로 이것이 스프링이 애플리케이션 프레임워크라고 불리는 이유이다.

그래서 흔히 스프링 MVC 프레임워크 또는 JDBC/ORM 지원 프레임워크라고 생각하는 것은 스프링이 다루는 일부 영역만 봤기 때문이다. 또, 스프링을 IoC/DI 프레임워크나 AOP 툴이라고 보는 이유는 스프링이 제공하는 핵심 기술에만 주목했기 때문이기도 하다. 

결국 **스프링의 일차적인 존재 목적은 핵심 기술에 담긴 프로그래밍 모델을 일관되게 적용해서 엔터프라이즈 애플리케이션 전 계층과 전 영역에 전략과 기능을 제공해줌으로써, 애플리케이션을 편리하게 개발하게 해주는 애플리케이션 프레임워크로 사용되는 것임을 알아야 한다.**

#### 경량급
다음로 알아볼 스프링의 정의는 경량급이다. 여기서 이야기 하는 경량급이라는건 스프링이 아주 가볍거나 혹은 규모가 작다는 내용이 아니라 `불필요하게 무겁지 않다는 의미`이다. 
이 것은 스프링 이전에 나왔던 EJB(Enterprise Java Beans)에 대해 생각해봐야하는데, 당시에 나온 EJB의 경우 개발환경과 운용서버, 개발과 빌드, 테스트 과정, 작성된 코드 모두를 매우 무겁고 복잡하게 만들었었고 EJB가 동작하려면, 고가의 느리고 무거운 자바 서버(WAS)가 필요했었다. 
또한, 툴의 도움 없이는 다루기 힘든 난해한 설정파일 구조와 까다로운 패키징, 불편한 서버 배치(deploy) 등으로 인한 부담 때문에 고가의 제품으로 구성된 제대로 된 개발환경을 갖추지 않고는 개발하기가 힘들었다.

```
그에 반해 스프링은 가장 단순한 서버환경인 톰캣(Tomcat)이나 제티(Jetty)에서도 완벽하게 동작했고, 
단순한 개발툴과 기본적인 개발환경으로도 엔터프라이즈 개발에서 필요로 하는 주요한 기능을 갖춘 
애플리케이션을 개발하기에 충분하게 되었다.  
서블릿 컨테이너만으로 충분하니 EJB 컨테이너를 비롯해 복잡한 기능이 잔뜩 포함된 고급 WAS를
굳이 사용하지 않아도 되게 된 것이다.
```

결과적으로 **스프링은 EJB를 대표로 하는 기존의 많은 기술이 불필요하게 무겁고 복잡했음을 증명한 셈이고, 
그런 면에서 스프링은 군더더기 없이 깔끔한 기술을 가진 '경량급' 프레임워크라고 불리게 된 것이다.**

#### 자바 엔터프라이즈 개발을 편하게
자바 엔터프라이즈 개발을 편하게 해주기 위해 등장한 프레임워크는 사실 스프링이 최초는 아니다. 
그전에 많은 프레임워크가 등장했었고, 그 중 대표적으로 말하는 프레임워크가 EJB이다. 
EJB가 처음 등장했을때에는 일정 부분에서는 엔터프라이즈 개발의 고민거리와 부담을 덜어줬었다.
하지만 **개발을 편하게 해주기 위해 다른 차원의 더 큰 복잡함을 애플리케이션 개발에 끌고 오게 되었고** 
결국 배보다 배꼽이 더 크게 되는 상황이 오게 되었다.(자세한 내용은 하단에 다룬다.)

그 뒤에 스프링이 등장함으로써, 개발자들이 스프링이라는 프레임워크가 제공하는 기술이 아니라 **자신이 작성하는 애플리케이션의 로직에 더 많은 관심과 시간을 보장해주게 되었고,** 초기에 스프링의 기본 설정과 적용 기술만 잘 선택하고 준비해두면, 이후로 애플리케이션 개발 중에는 스프링과 관련된 코드나 API에 대해 개발자가 거의 신경 쓸 일이 없게 되었다. 즉, **말그대로 개발을 편하게 할 수 있게 만들어 준 것이다.**


#### 오픈소스
우리가 생각하는 오픈소스는 무엇일까? 다들 알다 시피 모두가 개발에 참여할 수 있고, 또 어느 누구나 버그 리포트도 가능하고 어느 누구가 그걸 해결하는 즉, 개방적으로 모두 참여할 수 있는 프로젝트라고 생각할 것이다. 하지만 이 것은 장점이자 단점이 될 수 있는데 **그 것은 지속적이고 안정적인 개발이 계속될지가 불확실하다는 것이다.**
예를 들면, 개발자의 개인적인 사정으로 인해 개발을 더 진행할 수 없거나, 개발자가 중간에 교체되거나, 개발팀에 불화가 생겨서 개발을 정상적으로 진행하기가 힘든 경우 등이 있을 것이다.

그래서 스프링은 이러한 오픈소스의 단점이자 한계를 잘 알고있어 정책은 오픈소스를 택하였지만 사용자에게 지속적인 신뢰를 주기 위해 개발에 관련된 사항은 한정적으로 개발을 책임질 수 있는 `전문 개발 기업을 채택`하게 되었다. 그래서 스프링은 오픈소스의 장점을 충분히 취하면서 동시에 오픈소스 제품의 단점과 한계를 잘 극복하고 있는, 전문적이고 성공적인 오픈소스 소프트웨어라고 할 수 있다.


### 스프링의 목적
---

그렇다면 스프링의 목적은 무엇일까요? 스프링이 만들어진 이유는 무엇이고, 스프링을 통해 궁극적으로 이루려고 하는 것은 무엇일까? 그것은 정의를 통해 살펴봤듯이 `경량급 프레임워크인 스프링을 활용해서 엔터프라이즈 애플리케이션 개발을 편하게 하는 것`이다. 
그렇다면 굳이 스프링을 사용해서 엔터프라이즈 개발을 편하게 하려는 이유는 무엇일까? 원래 엔터프라이즈 개발이란 편하지 않기 때문이다.

#### 엔터프라이즈 개발의 복잡함
2000년대 초반 각종 자바 컨퍼런스에서 자주 논의됐던 주제는 '왜 자바 엔터프라이즈(JavaEE) 프로젝트는 실패하는가?'였다. 당시 IT 리서치기업의 조사에 따르면 80% 이상의 자바 엔터프라이즈 프로젝트가 실패했다고 했다.
그 이유는 무엇일까? 그것은 바로 `엔터프라이즈 시스템 개발이 너무 복잡해져서`였다.

- 복잡함을 가중시키는 원인
복잡하다는 건 단지 양이 많고 어렵다는 뜻이 아니다. 세부 요소가 이해하기 힘든 방식으로 얽혀 있고, 그 때문에 쉽게 다루기 어렵다는 의미이다. 예를 들어, 고객의 기존 거래내역을 분석하고 그 특성을 파악해서 그에 따른 적절한 추천상품을 선정하는 로직을 담당하는 코드를 작성한다고 생각해보자.
```
작업 요청을 XML 문서를 통한 리모팅 서비스로 받기 때문에 그것을 파싱해서 고객 ID를 추출하기 위해 
XML 파서 라이브러리를 사용해야 하고, 고객의 최신 정보를 얻기 위해 DB를 조회할 때 캐시를 먼저 점검하려고 
캐시 API를 호출하고, 없으면 서버가 제공하는 DB 풀에서 커넷션을 가져와서 JDBC API를 이용해 
다양한 타입의 필드로 된 정보를 가져와야 한다. 
가져온 정보를 분석한 내용을 만일을 위해 로그로 남겨놓도록 분산 파일 시스템을 이용하는 로그 라이브러리를 
매번 호출한다. 
현재 요청을 보낸 사용자의 정보를 보안 API를 통해 가져와 요청한 작업에 대한 권한이 있는지도 파악해야 하고, 권한이 없으면 그에 따른 예외를 발생시켜야 한다. 
최종적으로 추천상품으로 선정한 내역을 로컬 DB에 저장하고 메시지로도 전송해야 하는데, 반드시 하나의 트랜잭션 안에서 동작해야 한다.
```
이러한 로직을 구현하게 되면 굉장히 만만치 않은 작업이 될 것이고 다양한 예외에 대해서도 신경써야 될 것이다. 또, 최악의 경우엔 특정 부분을 바꾸어야 된다면, 어떻게될지 상상해보자. 
**결국, 이러한 문제로 인해 엔터프라이즈의 개발은 굉장히 복잡한 개발이었다.**

- 복잡합의 근본적인 이유
엔터프라이즈 시스템 개발이 복잡한 원인은 크게 두 가지가 있다.
  - 기술적인 제약조건과 요구사항이 늘어가기 때문이다.
  - 엔터프라이즈 애플리케이션이 구현해야 할 핵심기능인 비즈니스 로직의 복잡함이 증가하기 때문이다.

전통적인 자바 엔터프라이즈 개발 기법은 대부분 비즈니스 로직의 복잡한 구현 코드와 엔터프라이즈 서비스를 이용하는 기술적인 코드가 자꾸 혼재될 수 밖에 없는 방식이었다.  **결국 개발자가 동시에 그 두 가지를 모두 신경 써서 개발해야 하는 과도한 부담을 줬고, 그에 따라 전체적인 복잡함은 몇 배로 가중됐다.**

- 실패한 해결책: EJB
EJB의 기본 전략은 위의 두가지 종류의 복잡함을 분리하는 것이었다. 
개발자가 로우레벨의 기술적인 복잡함에 신경 쓰지 않고 비즈니스 로직을 효과적으로 개발하는 데  더 집중할 수 있게 하자는 목표가 있었다. 하지만 기존 EJB는 결과적으로 그런 목표를 달성하는 데 실패했다. 
EJB는 기술적인 복잡함을 애플리케이션의 핵심 로직에서 일부분 분리하는 데 성공하긴 했다. 
선언적 트랜잭션이나 선언적 보안, 컨테이너를 통한 리모팅 기술의 적용, 컴포넌트 단위의 배치, JNDI를 통한 서비스 검색 지원, 서비스 오브젝트의 풀링, 컴포넌트 생명주기 관리 등은 EJB의 목표를 어느 정도 충족시켜 줬지만,  EJB 환경에서 동작하기 위해 특정 인터페이스를 구현하고, 특정 클래스를 상속하고, 서버에 종속적인 서비스를 통해서만 접근하고 사용이 가능하게 만드는 등의 EJB 개발 방식은 잘못된 선택이었다. 
**애플리케이션 로직을 담은 핵심 코드에서 일부 기술적인 코드가 제거된 건 사실이지만, 오히려 EJB라는 환경과 스펙에 종속되는 코드로 만들어져야 하는 더 큰 부담을 안게 되었기 때문이다.**

EJB는 결국 일부 기술적인 복잡함을 덜어주려는 시도를 하다가 오히려 더 큰 복잡함을 추가하는 실수를 범하게 되었다. 가장 치명적인 건, **EJB라는 틀 안에서 자바 코드를 만들게 강제함으로써 자바 언어가 원래 갖고 있던 장점마저 잃어버렸다는 것이다. ** EJB의 특정 클래스를 상속하게 함으로써 더 이상 상속구조를 적용하지 못하게 만들거나, 다형성 적용을 근본적으로 제한한다거나 하는 것들이다.  EJB는 결국 객체지향적인 특성을 잃어버린 밋밋한 서비스 스크립트성 코드로 변질되었고, 별다른 장점은 없는데다 개발 방식은 너무 불편했기 때문에 
개발자에게 점점 외면당하는 신세가 되어 버렸다.

#### 복잡함을 상대하는 스프링의 전략
스프링의 기본적인 전략은 **비즈니스 로직을 담은 애플리케이션 코드와 엔터프라이즈 기술을 처리하는 코드를 분리시키는 것이다.** 이 분리를 통해 두 가지 복잡함의 문제를 효과적으로 공략하게 해준다.

- 기술적 복잡함을 상대하는 전략
기술적인 복잡함을 분리해서 생각하면 그것을 효과적으로 상대할 수 있는 적절한 전략을 발견할 수 있다. 
스프링은 엔터프라이즈 기술을 적용했을 때 발생하는 복잡함의 문제를 두 가지로 분류하고 각각에 대한 적절한 대응 방법을 제공한다.

  - 첫 번째 문제 : 기술에 대한 접근 방식이 일관성이 없고, 특정 환경에 종속적이다.
일관성 없는 기술과 서버환경의 변화에 대한 스프링의 공략 방법은 바로 서비스 추상화다. 
앞에서 보았던 트랜잭션 추상화, OXM 추상화, 데이터 액세스에 관한 일관된 예외변환 기능, 데이터 액세스 기술에 독립적으로 적용 가능한 트랜잭션 동기화 기법 등이 대포적인 예다.  기술적인 복잡함은 일단 `추상화`를 통해 로우레벨의 기술 구현 부분과 기술을 사용하는 `인터페이스를 분리`하고, 환경과 세부기술에 독립적인 접근 인터페이스를 제공하는 것이 가장 좋은 해결책이다.

  - 두 번째 문제 : 기술적인 처리를 담당하는 코드가 성격이 다른 코드에 섞여서 등장한다.
**책임에 따라 계층을 구분하고 그 사이에 서로의 기술과 특성에 의존적인 인터페이스나 예외처리 등을 최대한 제거한다고 할지라도 근본적으로 엔터프라이즈 서비스를 적용하는 한 이런 문제는 쉽게 해결할 수 없다.**
이런 기술과 비즈니스 로직의 혼재로 발생하는 복잡함을 해결하기 위한 스프링의 접근 방법은 바로 `AOP`다.
AOP는 최후까지 애플리케이션 로직을 담당하는 코드에 남아 있는 기술 관련 코드를 깔끔하게 분리해서 별도의 모듈로 관리하게 해주는 강력한 기술이다.

- 비즈니스와 애플리케이션 로직의 복잡함을 상대하는 전략
비즈니스 로직의 복잡함을 상대하는 전략은 자바라는 객체지향 기술 그 자체다.  스프링은 단지 객체지향 언어의 장점을 제대로 살리지 못하게 방해했던 요소를 제거하도록 도와줄 뿐이다.

- 핵심 도구 : 객체지향과 DI
객체지향의 설계 기법을 잘 적용할 수 있는 구조를 만들기 위해 DI 같은 유용한 기술을 편하게 적용하도록 도와주는 것이 스프링의 기본 전략이다. 지금까지 보았듯이 기술적인 복잡함을 효과적으로 다루게 해주는 기법은 모두 DI를 바탕으로 하고 있다. 서비스 추상화, 템플릿/콜백, AOP와 같은 스프링의 기술은 DI 없이는 존재할 수 없는 것들이다.그리고 DI는 객체지향 설계 기술 없이는 그 존재의미가 없다. 
DI란 특별한 기술이라기보다는 유연하게 확장할 수 있는 오브젝트 설계를 하다 보면 자연스럽게 적용하게 되는 객체지향 프로그래밍 기법일 뿐이다. 스프링은 단지 그것을 편하고 쉽게 사용하도록 도와줄 뿐이다.
**기술적인 복잡함을 해결하는 문제나 기술적인 복잡함이 비즈니스 로직에 침범하지 못하도록 분리하는 경우에도 DI가 바탕이 된 여러 가지 기법이 활용된다. 반면에 비즈니스 로직 자체의 복잡함을 해결하려면 DI보다는 객체지향 설계 기법이 더 중요하다.**

### POJO 프로그래밍
---
스프링 핵심 개발자들은 스프링의 정수(essence)는 엔터프라이즈 서비스 기능을 POJO에 제공하는 것이라고 했다. 엔터프라이즈 서비스라고 하는 것은 보안, 트랜잭션과 같은 엔터프라이즈 시스템에서 요구되는 기술을 말한다. 이런 기술을 POJO에 제공한다는 말은, 뒤집어 생각해보면 엔터프라이즈 서비스 기술과 POJO라는 애플리케이션 로직을 담은 코드를 분리했다는 뜻이기도 하다. 
`분리됐지만 반드시 필요한 엔터프라이즈 서비스 기술을 POJO 방식으로 개발된 애플리케이션 핵심 로직을 담은 코드에 제공한다`는 것이 스프링의 가장 강력한 특징과 목표다.

#### 스프링의 핵심: POJO
스프링의 핵심이 POJO 프로그램이이라는 사실은, 스프링의 핵심을 가장 나타내고 있다고 알려진 아래 스프링 삼각형을 통해서도 잘 알 수 있다.  이 그림은 스프링 소스의 CTO인 아드리안 콜리어가 스프링의 핵심 개념을 설명하기 위해 만들었다고 한다.

![pojo-digram](/assets/img/posts/pojo-digram.png)

위의 그림은 스프링으로 개발한 애플리케이션의 기본 구조를 보여준다. 
스프링 애플리케이션은 POJO를 이용해서 만든 애플리케이션 코드와, POJO가 어떻게 관계를 맺고 동작하는지를 정의해놓은 설계정보로 구분된다. **DI의 기본 아이디어는 유연하게 확장 가능한 오브젝트를 만들어두고 그 관계는 외부에서 다이나믹하게 설정해준다는 것이다.**  이런 DI의 개념을 애플리케이션 전반에 걸쳐 적용하는 것이 스프링의 프로그래밍 모델이다.

스프링의 주요 기술인 `IoC/DI`, `AOP`와 `PSA(Portable server abstractions)`는 애플리케이션을 **POJO로 개발할 수 있게 해주는 가능기술(enabling technology)**이라고 불리운다.

#### POJO란 무엇인가?
스프링 애플리케이션 개발의 핵심인 POJO를 좀 더 자세히 알아보자. 
POJO는 Plain Old Java Object의 첫 글자를 따서 만든 약자이다. 최근 몇년간 자바에서 유행어처럼 사용되고 있는 이 단어는 마틴 파울러라는 사람이 2000년에 컨퍼런스 발표를 준비하다가 만들어낸 용어라고 한다. 마틴 파울러는 당시 인기를 끌고 있던 EJB처럼 복잡하고 제한이 많은 기술을 사용하는 것보다는 **자바의 단순한 오브젝트를 이용해 애플리케이션의 비즈니스 로직을 구현하는 편이 낫다고 생각했지만, 왜 개발자는 자바의 단순한 오브젝트를 사용하길 꺼리는지 궁금해 했다.** 그 이유를 찾아보니 평범한 자바오브젝트에는 EJB와 같은 그럴싸한 이름이 없기 때문이란걸 알게 됬다. **그래서 뭔가 있어 보이도록 만든 이름이 바로 POJO였다.** 같은 설명이지만 그냥 `간단한 자바오브젝트를 사용하는데요`라고 말하는 것보다 `POJO 방식의 기술을 사용합니다`라고 하면 왠지 세련되고 첨단기술을 쓰는 것처럼 느껴진다는 심리를 이용한 것이였고, 단지 POJO라는 폼 나는 이름 때문만은 아니겠지만, 아무튼 그 이후로 POJO 프로그래밍에 관한 개발자들의 관심이 높아졌고 POJO를 지원한다는 걸 장점으로 내세우는 많은 프레임워크 기술이 쏟아져 나오기 시작했다.


#### POJO의 조건
단순하게 보자면 그냥 평범한 자바오브젝트라고 할 수 있지만 좀 더 명확하게 하자면 적어도 다음의 조건을 충족해야 POJO라고 불릴 수 있다.

- 특정 규약에 종속되지 않는다.
POJO는 자바 언어와 꼭 필요한 API 외에는 종속되지 않아야 한다. 
따라서 EJB2와 같이 특정 규약을 따라 비즈니스 컴포넌트를 만들어야 하는 경우는 POJO가 아니다. 
특정 규약을 따라 만들게 하는 경우는 대부분 규약에서 제시하는 특정 클래스를 상속하도록 요구한다. 
그럴 경우 자바의 단일 상속 제한 때문에 더 이상 해당 클래스에 객체지향적인 설계 기법을 적용하기가 어려워지는 문제가 생긴다. 또한, 규약이 적용된 환경에 종속적이 되기 때문에 다른 환경으로 이전이 힘들다는 문제점이 있다.

- 특정 환경에 종속되지 않는다.
어떤 경우는 특정 벤더의 서버나 특정 기업의 프레임워크 안에서만 동작 가능한 코드로 작성되기도 한다. 
또 환경에 종속적인 클래스나 API를 직접 쓴 경우도 있다. 
순수한 애플리케이션 로직을 담고 있는 오브젝트 코드가 특정 환경에 종속되게 만드는 경우라면 그것 역시 POJO라고 할 수 없다. POJO는 환경에 독립적이어야한다.
특히 비즈니스 로직을 담고 있는 POJO 클래스는 웹이라는 환경정보나 웹 기술을 담고 있는 클래스나 인터페이스를 사용해서는 안된다. 비즈니스 로직을 담은 코드에 HttpServletRequest나 HttpSession, 캐시와 관련된 API가 등장하거나 웹 프레임워크의 클래스를 직접 이용하는 부분이 있다면 그것은 진정한 POJO라고 볼 수 없다. 단지 자바의 문법을 지키고, 순수하게 JavaSE API만을 사용했다고 해서 그 코드를 POJO라고 할 수는 없다. POJO는 객체지향적인 자바 언어의 기본에 충실하게 만들어져야 하기 때문이다.

#### POJO의 장점
POJO가 될 수 있는 조건이 그대로 POJO의 장점이 된다.
특정한 기술과 환경에 종속되지 않는 오브젝트는 그만큼 깔끔한 코드가 될 수 있다. 로우레벨의 기술과 환경에 종속적인 코드가 비즈니스 로직과 함께 섞여 나오는 것만큼 지저분하고 복잡한 코드도 없다.
POJO로 개발된 코드는 자동화된 테스트에 매우 유리하다. 환경의 제약은 코드의 자동화된 테스트를 어렵게 한다. 
컨테이너에서만 동작을 확인할 수 있는 EJB 2는 테스트하려면 서버의 구동 및 빌드와 배치 과정까지 필요하다. 
자동화된 테스트가 불가능한 건 아니지만 매우 복잡하고 번거로우므로 대부분 수동 테스트 방식을 선호한다. 
그에 반해 어떤 환경에도 종속되지 않은 POJO 코드는 매우 유연한 방식으로 원하는 레벨에서 코드를 빠르고 명확하게 테스트할 수 있다.
객체지향적인 설계를 자유롭게 적용할 수 있다는 것도 큰 장점이다.

#### POJO 프레임워크
스프링은 POJO를 이용한 엔터프라이즈 애플리케이션 개발을 목적으로 하는 프레임워크이다. 
POJO 프로그래밍이 가능하도록 기술적인 기반을 제공하는 프레임워크를 POJO 프레임워크라고 한다. 
스프링은 엔터프라이즈 애플리케이션 개발의 모든 영역과 계층에서 POJO 방식의 구현이 가능하게 하려는 목적으로 만들어졌다. 스프링을 이용하면 POJO 프로그래밍의 장점을 그대로 살려서 **엔터프라이즈 애플리케이션의 핵심 로직을 객체지향적인 POJO를 기반으로 깔끔하게 구현하고, 동시에 엔터프라이즈 환경의 각종 서비스와 기술적인 필요를 POJO 방식으로 만들어진 코드에 적용할 수 있다.**
스프링은 비즈니스 로직의 복잡함과 엔터프라이즈 기술의 복잡함을 분리해서 구성할 수 있게 도와준다. 
하지만 자신은 기술영역에만 관여하지 비즈니스 로직을 담당하는 POJO에서는 모습을 감춘다. 데이터 액세스 로직이나 웹 UI 로직을 다룰 때만 최소한의 방법으로 관여한다. POJO 프레임워크로서 **스프링은 자신을 직접 노출하지 않으면서 애플리케이션을 POJO로 쉽게 개발할 수 있게 지원해준다.**

지금까지 스프링은 무엇인가? 라는 막연한 질문에 대해 스프링이 탄생하게된 계기, 스프링의 정의, 스프링의 목적 들을 보면서 그저 스프링이 바로 탄생한게 아니라 스프링을 만들기 위한 수많은 실패과정들이 있었다는 것을 알게 되었고 지금까지 단순히 가져다 쓴 것에 대해 많은 반성을 하게 되었다.
이후로는 조금더 스프링의 철학에 대해 생각하면서 단순히 가져다 쓰는 것이 아닌 이해를 가지고 사용해야 겠다.


### 참고
---
- [스프링이란 무엇인가?](https://12bme.tistory.com/157)
- [토비의 스프링 8장 (스프링이란 무엇인가?)](https://jongmin92.github.io/2018/05/20/Spring/toby-8/)
